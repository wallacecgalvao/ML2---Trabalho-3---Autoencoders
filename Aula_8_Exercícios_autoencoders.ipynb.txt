{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "goB_v9B_oUEa"
   },
   "source": [
    "# Exercício para sala de aula - Autoencoder\n",
    "\n",
    "### **Introdução e objetivos:** \n",
    "Este notebook é um material complementar a disciplina de Aprendizado de Máquinas 2. O objetivo é reforçar os conteúdos da aula de autoencoders. Vamos utilizar algumas das técnicas aqui para desenvolver um autoencoder para recnostrução das imagens do Fashion MNIST.\n",
    "\n",
    "Como observamos em sala, existem várias aplicações que podem ser desenvolvidas a partir dos autoencoders: redução de dimensionalidade, classificação, remoção de ruído e etc.\n",
    "\n",
    "### **Execução:** \n",
    "A execução deste notebook será feita através do Colab direto do Google Drive. Não existe impedimento para que este notebook seja executado em outro ambiente desde que os pacotes necessários estejam instalados corretamente. \n",
    "\n",
    "É recomendável executar este treinamento em um ambiente com GPU. O tamanho da rede aumentou bastante com relação aos exemplo que vimos em sala tornando o tempo de treinamento mais custoso.\n",
    "\n",
    "### **Exercícios**\n",
    "\n",
    "**Exercício 1** - Amarre os pesos do encoder com o decoder para tornar o treinamento mais eficiente\n",
    "\n",
    "**Exercício 2** - Experimente ao menos duas arquiteturas (número de camadas, número de neurônios nas camadas escondidas e número de neurônios na camada de codificação) diferentes para este autoencoder. \n",
    "\n",
    "**Exercício 3** - Aplique o encoder treinado para treinamento supervisionado.\n",
    "\n",
    "**Exercício 4** - Avalie a solução final do modelo supervisionado respondendo algumas perguntas"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "lU4y71WJvD7T"
   },
   "source": [
    "Pacotes necessários"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "x5diWcl-QmCy"
   },
   "outputs": [],
   "source": [
    "# Reprodutibilidade\n",
    "import numpy as np\n",
    "from numpy.random import seed\n",
    "import tensorflow as tf\n",
    "from tensorflow.keras.utils import to_categorical\n",
    "from tensorflow.math import confusion_matrix"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "XOLMNl0gR53y"
   },
   "outputs": [],
   "source": [
    "# Treinamento e construção da rede neural\n",
    "import keras\n",
    "from keras.layers import Input, Dense\n",
    "from keras.models import Model, Sequential\n",
    "from keras.utils.vis_utils import plot_model\n",
    "from keras.datasets import fashion_mnist\n",
    "from keras import utils\n",
    "from keras import metrics\n",
    "\n",
    "# Visualização\n",
    "from matplotlib import pyplot as plt\n",
    "import matplotlib.image as mpimg\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "from sklearn.metrics import ConfusionMatrixDisplay\n",
    "from sklearn.model_selection import train_test_split\n",
    "\n",
    "import plotly.graph_objects as go\n",
    "import pandas as pd\n",
    "\n",
    "seed(1)\n",
    "tf.random.set_seed(2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "ffnCNLVGvH9J"
   },
   "source": [
    "Verificando a execução com aceleração em GPU"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "LOQnq3ecNjOH"
   },
   "outputs": [],
   "source": [
    "!nvidia-smi"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "DndwKRQdvLdZ"
   },
   "source": [
    "## **Exercício 1** - Amarre os pesos do encoder com o decoder para tornar o treinamento mais eficiente\n",
    "\n",
    "Neste exercício o seu objetivo é amarrar os pesos do *encoder* com o *decoder* com objetivo de tornar o treinamento mais eficiente. Nós vimos este exemplo no notebook da Aula 7 que está disponível no moodle."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "TY3nuxKhYl-S"
   },
   "outputs": [],
   "source": [
    "# class DenseTranspose(keras.layers.Layer):\n",
    "# ..."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "NTDaEQ_Kc43D"
   },
   "source": [
    "## **Exercício 2** - Experimente ao menos duas arquiteturas (número de camadas, número de neurônios nas camadas escondidas e número de neurônios na camada de codificação) diferentes para este autoencoder. \n",
    "\n",
    "*Uma dica: salve as configurações da rede que vocês estão experimentando ou versionem o notebook. Você irá precisar dessas referências no final do notebook para responder as perguntas do **Exercício 4**.*"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "C3F37MoBYw-V"
   },
   "outputs": [],
   "source": [
    "encoding_dim = 32\n",
    "\n",
    "\n",
    "tied_encoder = keras.models.Sequential([\n",
    "# ...\n",
    "])\n",
    "\n",
    "\n",
    "tied_decoder = keras.models.Sequential([\n",
    "# ...\n",
    "])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "fB4N5gzEvXYd"
   },
   "source": [
    "Instanciando o autoencoder"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "9L-EW7PEUVGN"
   },
   "outputs": [],
   "source": [
    "autoencoder = keras.models.Sequential([tied_encoder, tied_decoder])\n",
    "autoencoder.compile(optimizer='adam', loss='binary_crossentropy')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "Du1TJuGLvbDT"
   },
   "outputs": [],
   "source": [
    "print(autoencoder.summary())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "IZa5vaaPvehO"
   },
   "source": [
    "Instanciando o encoder"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "4a-tb9A-xC9C"
   },
   "outputs": [],
   "source": [
    "print(tied_encoder.summary())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "_U_Nn11Zvhip"
   },
   "source": [
    "Instanciando o decoder"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "jbYISJgNxEnk"
   },
   "outputs": [],
   "source": [
    "print(tied_decoder.summary())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "zxG_gsCivnjD"
   },
   "source": [
    "Leitura e pré-processamento dos dados"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "5NNW318hQPCy"
   },
   "outputs": [],
   "source": [
    "(x_train, y_train), (x_temp, y_temp) = fashion_mnist.load_data()\n",
    "\n",
    "# Estou separando aqui um conjunto de dados que serão utilizados (x_valid, y_valid) na etapa de treinamento supervisionado.\n",
    "# Este será o nosso conjunto de dados anotados. No restante das etapas não faremos uso das anotações.\n",
    "x_test, x_valid, y_test, y_valid = train_test_split(x_temp, y_temp, test_size=0.33)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "XaoEvcqFQQEZ"
   },
   "outputs": [],
   "source": [
    "x_train = x_train.astype('float32') / 255.\n",
    "x_test = x_test.astype('float32') / 255.\n",
    "print(x_train.shape)\n",
    "print(x_test.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "Utx5PYGhQRiJ"
   },
   "outputs": [],
   "source": [
    "%%time\n",
    "history = autoencoder.fit(x_train, x_train,\n",
    "                epochs=100,\n",
    "                batch_size=512,\n",
    "                shuffle=True,\n",
    "                validation_data=(x_test, x_test),\n",
    "                verbose = 1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "-jtBMnXNQsMT"
   },
   "outputs": [],
   "source": [
    "print(history.history.keys())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "HVCt7ckxQzfm"
   },
   "outputs": [],
   "source": [
    "plt.plot(history.history['loss'])\n",
    "plt.plot(history.history['val_loss'])\n",
    "plt.title('model train vs validation loss')\n",
    "plt.ylabel('loss')\n",
    "plt.xlabel('epoch')\n",
    "plt.legend(['train', 'validation'], loc='upper right')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "RWoaTPeVQTDo"
   },
   "outputs": [],
   "source": [
    "decoded_imgs = autoencoder.predict(x_train)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "GQT_HG9jQWBG"
   },
   "outputs": [],
   "source": [
    "n = 5 \n",
    "plt.figure(figsize=(10, 2))\n",
    "for i in range(n):\n",
    "    # display original\n",
    "    ax = plt.subplot(2, n, i + 1)\n",
    "    plt.imshow(x_train[i].reshape(28, 28))\n",
    "    plt.gray()\n",
    "    ax.get_xaxis().set_visible(False)\n",
    "    ax.get_yaxis().set_visible(False)\n",
    "\n",
    "    # display reconstruction\n",
    "    ax = plt.subplot(2, n, i + 1 + n)\n",
    "    plt.imshow(decoded_imgs[i].reshape(28, 28))\n",
    "    plt.gray()\n",
    "    ax.get_xaxis().set_visible(False)\n",
    "    ax.get_yaxis().set_visible(False)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "hLN0Yi08dc2J"
   },
   "source": [
    "## **Exercício 3** - Aplique o encoder treinado para treinamento supervisionado."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "-tORNxk3dvZb"
   },
   "outputs": [],
   "source": [
    "def rounded_accuracy(y_true, y_pred):\n",
    "    return keras.metrics.binary_accuracy(tf.round(y_true), tf.round(y_pred))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "bJ4G0ua5g_Bn"
   },
   "outputs": [],
   "source": [
    "\n",
    "# class_model = ..."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "--xgSwf3Wz6y"
   },
   "outputs": [],
   "source": [
    "class_model.compile(loss='categorical_crossentropy',\n",
    "                   optimizer='adam', metrics=[metrics.AUC()])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "10pn1CJEd6jE"
   },
   "outputs": [],
   "source": [
    "class_model.summary()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "XHQCNDFbd931"
   },
   "outputs": [],
   "source": [
    "y_train = to_categorical(y_train, 10)\n",
    "y_test = to_categorical(y_test, 10)\n",
    "history = class_model.fit(x_train, y_train, validation_data=(x_test, y_test), epochs=2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "MfoiOpywasvf"
   },
   "source": [
    "## **Exercício 4** - Avalie a solução final do modelo supervisionado. Responda ao final as seguintes perguntas:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "yo-Yp8ANauAu"
   },
   "source": [
    "**Como você analisa a solução final?**\n",
    "\n",
    "\n",
    "Resposta:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "VnsYiaB6bSd3"
   },
   "source": [
    "**Quais ponderações você faz sobre o pipeline utilizado para o desenvolvimento deste modelo?**\n",
    "\n",
    "Resposta:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "-CEpcq-FbY7i"
   },
   "source": [
    "**Seria possível utilizar um número de neurônios menor na camada de codificação? Qual o impacto dessa redução?**\n",
    "\n",
    "Resposta:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "OCPIse9dl2t1"
   },
   "source": [
    "**Qual o impacto no modelo de classificação de congelar ou não os pesos?**\n",
    "\n",
    "Resposta:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "8VnChPGmatKq"
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "accelerator": "GPU",
  "colab": {
   "collapsed_sections": [],
   "provenance": []
  },
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
